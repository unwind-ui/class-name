# Stateful class names

**As oppose to stateless, any`className` define to be dependent on props or state is considered statefull.**
It exposes component's state to any callback that would want to derive it's CSS classes based on the passed state.

**Type:** [ClassNameCallback](../../api/class-name/type/class-name-callback)

## Defining stateful `className` value

Use functions or closures to define a stateful `className` value callback.
It is not required to wrap callbacks with [`defineClassName()`](../../api/class-name/function/define-class-name)
but that would require you to define both types of arguments manually.

### Arguments

#### State object {#state-object}

The first argument of the callback class name is an object representing the state of the component.

```tsx
type MyComponentClassNameState = {
  active: boolean
}
```

#### Previously generated selectors parameter

The second argument of the callback class name is a list of selectors that were generated by the class names passed to the resolving method before your callback class name.
You might decide to discard all previous styles and start from scratch by omitting the second parameter altogether,
filter selectors or add extra selectors depending on your use-case.

If you only add selectors that are not directly tied to the state, you should consider creating a [stateless](stateless-class-names) class name instead.


### Defining manually

```tsx title="Manually 1: With type for the argument"
// highlight-next-line
import type { ClassNamePrimitive } from '@unwind/class-name'

type MyComponentClassNameState = {
  active: boolean
}

// highlight-next-line
const myComponentClassName = (state: MyComponentClassNameState, previous: ClassNamePrimitive[]) => [
  ...previous,
  ...[
    `active:${active}`,
  ]
]
```

or

```tsx title="Manually 2: With type for the variable"
// highlight-next-line
import type { ClassNameCallback } from '@unwind/class-name'

type MyComponentClassNameState = {
  active: boolean
}

// highlight-next-line
const myComponentClassName: ClassNameCallback = (state: MyComponentClassNameState, previous) => [
  ...previous,
  ...[
    `active:${active}`,
  ]
]
```

:::tip Unwind prefixes falsy selectors with `not:` prefix. See [config to opt out](../../config#transform-falsy-value).

Resulting HTML markup:

```html
<a href="not:active">This will work</a>
```

Use `\` to escape `:` when declaring CSS class that should include colon, e.g.:

```css
.not\:active {
  color: grey;
}
```
:::


### Defining with a method

```tsx title="Using a method"
// highlight-next-line
import { defineClassName } from '@unwind/class-name'

type MyComponentClassNameState = {
  active: boolean
}

// highlight-next-line
const myComponentClassName = defineClassName((state: MyComponentClassNameState, previous) => [
  ...previous,
  ...[
    active ? 'my-component-is-active' : null,
  ]
])
```

---

When you use [`defineClassName()`](../../api/class-name/function/define-class-name) it turns your value into a [nested object](composed-class-names) under the hood.

<div className="container margin-after:p">
<div className="row flex items:center gap:2">
<div className="col--5 grow">

```tsx title="Definition"
const className = defineClassName(
  (
    state: MyComponentClassNameState,
    previous
  ) => [ ...previous, 'my-component' ]
)
```

</div>
<div className="col--2">&rarr;</div>
<div className="col--5 grow">

```tsx title="Resulting value"
const className = {
  [HOST_KEY]: [(
    state: MyComponentClassNameState,
    previous
  ) => [ ...previous, 'my-component' ]]
}
```

</div>
</div>
</div>
