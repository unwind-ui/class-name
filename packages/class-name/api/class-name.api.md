## API Report File for "@unwind/class-name"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type Alpha = AlphaLower | AlphaUpper;

// @public
export type AlphaLower = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';

// @public
export type AlphaUpper = Uppercase<AlphaLower>;

// @public
export type AnyObject = Record<string, unknown>;

// @public
export type ClassName<State extends AnyObject = EmptyObject> = HostClassName<State> | ClassNameObjectPartial<State>;

// @public
export type ClassNameCallback<State extends AnyObject = EmptyObject> = ((state: State, previous: ClassNamePrimitive[]) => ClassNamePrimitive[]);

// @public
export type ClassNameConfig = {
    analyzeArgumentsLength: boolean;
    transformFalsyValue: StringClassNameTransformer | false;
    transformNullishValue: StringClassNameTransformer | false;
    transformTruthyValue: StringClassNameTransformer | false;
    transformations: StringClassNameTransformer[];
};

// @public
export type ClassNameObject<State extends AnyObject = EmptyObject> = {
    [key: `${Alpha}${string}`]: HostClassName<State> | ClassNameObject<any>;
    [HOST_KEY]: HostClassName<State>;
};

// @public
export type ClassNameObjectPartial<State extends AnyObject = EmptyObject> = Partial<{
    [key: `${Alpha}${string}`]: HostClassName<State> | ClassNameObjectPartial<any>;
}> & {
    [HOST_KEY]?: HostClassName<State>;
};

// @public
export type ClassNamePrimitive = string | false | null | undefined;

// @public
export type ClassNameProp<V extends ClassName<any> = null> = V extends HostClassName<infer State> ? HostClassName<State> : V extends ClassNameObjectPartial<infer State> ? HostClassName<State> | {
    [P in keyof V]?: V[P] extends HostClassName<infer State> ? HostClassName<State> : V[P] extends ClassNameObjectPartial<any> ? ClassNameProp<V[P]> : never;
} : never;

// @public
export type CombineClassNameType<Base, Extension> = Base extends ClassNameObject<infer BaseState> ? Extension extends ClassNameObject<infer ExtensionState> ? {
    [P in keyof Base | keyof Extension]: P extends typeof HOST_KEY ? (string | ClassNameCallback<CombineStates<BaseState, ExtensionState>>)[] : P extends keyof Base ? P extends keyof Extension ? CombineClassNameType<Base[P], Extension[P]> : Base[P] : P extends keyof Extension ? Extension[P] : never;
} : never : never;

// @public
export type CombineStates<Base extends AnyObject, Extension extends AnyObject> = Merge<{
    [P in keyof Base | keyof Extension]: P extends keyof Base ? P extends keyof Extension ? Base[P] extends Extension[P] ? Extension[P] extends Base[P] ? Extension[P] : never : never : P extends DisjunctKeys<keyof Base, keyof Extension> ? never : Base[P] : P extends keyof Extension ? P extends DisjunctKeys<keyof Base, keyof Extension> ? never : Extension[P] : never;
}>;

// @public
export function defineClassName<State extends AnyObject, Value extends ClassName<State>, T extends ClassName<any> = Value>(selector: T): DefineClassNameType<ExtractState<T>, T>;

// @public
export type DefineClassNameType<OuterState extends AnyObject, V extends ClassName<OuterState>> = V extends HostClassName<infer State> ? {
    [HOST_KEY]: (string | ClassNameCallback<StateOrEmptyObject<State>>)[];
} : V extends ClassNameObjectPartial<infer State> ? Merge<{
    [HOST_KEY]: (string | ClassNameCallback<StateOrEmptyObject<State>>)[];
} & {
    [P in keyof V]: P extends typeof HOST_KEY ? (string | ClassNameCallback<StateOrEmptyObject<State>>)[] : V[P] extends HostClassName<infer State> ? {
        [HOST_KEY]: (string | ClassNameCallback<StateOrEmptyObject<State>>)[];
    } : V[P] extends ClassNameObjectPartial<infer State> ? DefineClassNameType<State, V[P]> : never;
}> : never;

// @public
export type DisjunctKeys<U1, U2> = Exclude<U1, U2> extends never ? never : Exclude<U2, U1> extends never ? never : Exclude<U1, U2> | Exclude<U2, U1>;

// @public
export type EmptyObject = Record<string, never>;

// @public
export type ExcludeFromCombinedState<T extends AnyObject, OwnState extends AnyObject> = {
    [P in Exclude<keyof T, keyof OwnState>]: T[P];
};

// @public
export type ExtractState<T> = T extends ClassName<infer State> ? {
    [P in keyof State]: State[P];
} : EmptyObject;

// @public
export const HOST_KEY: "$";

// @public
export type HostClassName<State extends AnyObject = EmptyObject> = HostClassNameMember<State> | HostClassNameMember<State>[];

// @public
export type HostClassNameMember<State extends AnyObject = EmptyObject> = ClassNamePrimitive | ClassNameCallback<State>;

// @public
export type HostClassNameObject<State extends AnyObject = EmptyObject> = {
    [HOST_KEY]: HostClassName<State>;
};

// @public
export type IncompatibleKeys<O> = O extends EmptyObject ? never : O extends Record<infer K, infer V> ? {
    [P in K]: O[P] extends never ? P : never;
}[K] : never;

// @public
export type Merge<U> = UnionToIntersection<U> extends infer O ? {
    [K in keyof O]: O[K];
} : never;

// Warning: (ae-extra-release-tag) The doc comment should not contain more than one release tag
//
// @public
export function mergeClassNames<BaseState extends AnyObject, ExtensionState extends AnyObject, Base extends ClassName<BaseState>, Extension extends ClassName<ExtensionState>, R extends (S extends EmptyObject ? never[] : IncompatibleKeys<S> extends never ? never[] : [Record<IncompatibleKeys<S>, never>]), B extends ClassName<any> = Base, E extends ClassName<any> = Extension, BB extends ClassName<any> = B, EE extends ClassName<any> = E, S extends AnyObject = CombineStates<ExtractState<B>, ExtractState<E>>>(base: B, extension: E, ...__INFERRED_STATES_MISMATCH_GUARD__: R): CombineClassNameType<DefineClassNameType<S, BB>, DefineClassNameType<S, EE>>;

// @public
export function resolveClassName<State extends AnyObject>(state: State, ...classNameList: (ClassName<State>)[]): string | undefined;

// @public
export function resolveClassNameDelegateFactory<WrapperState extends AnyObject, WrappedState extends AnyObject, T extends HostClassName<WrapperState & WrappedState> | HostClassNameObject<WrapperState & WrappedState>, ClassName = T>(wrapperState: WrapperState, className: ClassName): ResolveClassNameDelegateFactoryType<WrapperState, ClassName>;

// @public
export type ResolveClassNameDelegateFactoryType<OwnState extends AnyObject, T> = ClassNameCallback<ExcludeFromCombinedState<ExtractState<T>, OwnState>>;

// @public
export function setClassNameConfig(override: Partial<ClassNameConfig>): void;

// @public
export type StateOrEmptyObject<State> = TypeofState<State> extends never ? EmptyObject : State;

// @public
export type StringClassNameTransformer = (value: string | null) => string | null;

// @public
export type TypeofState<State> = UnionToIntersection<State extends EmptyObject ? 'EmptyObject' : State extends AnyObject ? 'AnyObject' : 'Other'>;

// @public
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// (No @packageDocumentation comment for this package)

```
